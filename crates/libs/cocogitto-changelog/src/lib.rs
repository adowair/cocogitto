use crate::error::ChangelogError;
use crate::release::{ChangelogCommit, Release};
use crate::renderer::Renderer;
use crate::template::{MonoRepoContext, PackageContext, RemoteContext, Template};
use chrono::Utc;
use cocogitto_commit::{Commit, CommitType};
use cocogitto_git::rev::CommitIter;
use cocogitto_git::Repository;
use cocogitto_oid::OidOf;
use colored::Colorize;
use log::warn;
use std::collections::HashMap;
use std::fs;
use std::path::Path;

pub mod error;
pub mod release;
pub(crate) mod renderer;
pub(crate) mod serde;
pub mod template;

const CHANGELOG_SEPARATOR: &str = "- - -";

const DEFAULT_HEADER: &str =
    "# Changelog\nAll notable changes to this project will be documented in this file. \
See [conventional commits](https://www.conventionalcommits.org/) for commit guidelines.\n\n- - -\n";

const DEFAULT_FOOTER: &str =
    "Changelog generated by [cocogitto](https://github.com/cocogitto/cocogitto).";

pub enum ReleaseType<'a> {
    Standard,
    MonoRepo(MonoRepoContext<'a>),
    Package(PackageContext<'a>),
}

/// ## Get a changelog between two oids
/// - `from` default value:latest tag or else first commit
/// - `to` default value:`HEAD` or else first commit
pub fn get_changelog<'a>(
    repository: &'a Repository,
    pattern: &str,
    allowed_commits: &[CommitType],
    omitted_commits: &HashMap<CommitType, bool>,
    changelog_titles: &HashMap<CommitType, String>,
    usernames: &HashMap<&'a str, &'a str>,
) -> Result<Release<'a>, ChangelogError> {
    let commit_range = repository.revwalk(pattern)?;
    release_from_commits(
        commit_range,
        allowed_commits,
        omitted_commits,
        changelog_titles,
        usernames,
    )
    .map_err(Into::into)
}

pub fn get_changelog_at_tag(
    repository: &Repository,
    tag: &str,
    template: Template,
    allowed_commits: &[CommitType],
    omitted_commits: &HashMap<CommitType, bool>,
    changelog_titles: &HashMap<CommitType, String>,
    usernames: &HashMap<&str, &str>,
) -> Result<String, ChangelogError> {
    let changelog = get_changelog(
        repository,
        tag,
        allowed_commits,
        omitted_commits,
        changelog_titles,
        usernames,
    )?;

    changelog.into_markdown(template).map_err(Into::into)
}

pub fn get_changelog_template(
    remote: Option<String>,
    repository: Option<String>,
    owner: Option<String>,
    template: &str,
) -> Result<Template, ChangelogError> {
    let context = RemoteContext::try_new(remote, repository, owner);
    Template::from_arg(template, context)
}

pub fn get_package_changelog_template(
    remote: Option<String>,
    repository: Option<String>,
    owner: Option<String>,
    template: &str,
) -> Result<Template, ChangelogError> {
    let context = RemoteContext::try_new(remote, repository, owner);

    let template = match template {
        "remote" => "package_remote",
        "full_hash" => "package_full_hash",
        template => template,
    };

    Template::from_arg(template, context)
}

pub fn get_monorepo_changelog_template(
    remote: Option<String>,
    repository: Option<String>,
    owner: Option<String>,
    template: &str,
) -> Result<Template, ChangelogError> {
    let context = RemoteContext::try_new(remote, repository, owner);

    let template = match template {
        "remote" => "monorepo_remote",
        "full_hash" => "monorepo_full_hash",
        template => template,
    };

    Template::from_arg(template, context)
}

pub fn release_from_commits<'a>(
    commits: CommitIter<'a>,
    allowed_commits: &[CommitType],
    omitted_commits: &HashMap<CommitType, bool>,
    changelog_titles: &HashMap<CommitType, String>,
    usernames: &HashMap<&'a str, &'a str>,
) -> Result<Release<'a>, ChangelogError> {
    let mut releases = vec![];
    let mut commit_iter = commits.into_iter().rev().peekable();

    while let Some((_oid, _commit)) = commit_iter.peek() {
        let mut release_commits = vec![];

        for (oid, commit) in commit_iter.by_ref() {
            if matches!(oid, OidOf::Tag(_)) {
                release_commits.push((oid, commit));
                break;
            }
            release_commits.push((oid, commit));
        }

        release_commits.reverse();
        releases.push(release_commits);
    }

    let mut current = None;

    for release in releases {
        let next = Release {
            version: release.first().unwrap().0.clone(),
            from: current
                .as_ref()
                .map(|current: &Release| current.version.clone())
                .unwrap_or(release.last().unwrap().0.clone()),
            date: Utc::now().naive_local(),
            commits: release
                .iter()
                .filter_map(
                    |(_, commit)| match Commit::from_git_commit(commit, allowed_commits) {
                        Ok(commit) => {
                            let commit_type = &commit.conventional.commit_type;
                            if !omitted_commits.get(commit_type).unwrap_or(&false) {
                                let author_username =
                                    usernames.get(commit.author.as_str()).cloned();
                                let changelog_title = changelog_titles
                                    .get(commit_type)
                                    .cloned()
                                    .unwrap_or(commit_type.to_string());
                                Some(ChangelogCommit::from_commit(
                                    commit,
                                    author_username,
                                    changelog_title,
                                ))
                            } else {
                                None
                            }
                        }
                        Err(err) => {
                            let err = err.to_string().red();
                            warn!("{}", err);
                            None
                        }
                    },
                )
                .collect(),
            previous: current.map(Box::new),
        };

        current = Some(next);
    }

    current.ok_or(ChangelogError::EmptyRelease)
}

impl Release<'_> {
    pub fn into_markdown(self, template: Template) -> Result<String, tera::Error> {
        let mut renderer = Renderer::try_new(template)?;
        renderer.render(self)
    }

    pub fn write_to_file<S: AsRef<Path>>(
        self,
        path: S,
        template: Template,
        kind: ReleaseType,
    ) -> Result<(), ChangelogError> {
        let renderer = Renderer::try_new(template)?;

        let mut renderer = match kind {
            ReleaseType::Standard => renderer,
            ReleaseType::MonoRepo(context) => renderer.with_monorepo_context(context),
            ReleaseType::Package(context) => renderer.with_package_context(context),
        };

        let changelog = renderer.render(self)?;

        let mut changelog_content = fs::read_to_string(path.as_ref())
            .unwrap_or_else(|_| [DEFAULT_HEADER, DEFAULT_FOOTER].join(""));

        let separator_idx = changelog_content.find(CHANGELOG_SEPARATOR);

        if let Some(idx) = separator_idx {
            changelog_content.insert(idx + CHANGELOG_SEPARATOR.len(), '\n');
            changelog_content.insert_str(idx + CHANGELOG_SEPARATOR.len() + 1, &changelog);
            changelog_content.insert_str(
                idx + CHANGELOG_SEPARATOR.len() + 1 + changelog.len(),
                "\n- - -\n",
            );
            fs::write(path.as_ref(), changelog_content)?;

            Ok(())
        } else {
            Err(ChangelogError::SeparatorNotFound(
                path.as_ref().to_path_buf(),
            ))
        }
    }
}

#[cfg(test)]
mod test {
    use cocogitto_config::Settings;
    use git2::Oid;
    use sealed_test::prelude::sealed_test;
    use sealed_test::prelude::*;
    use speculoos::prelude::*;

    use cocogitto_git::tag::TagLookUpOptions;
    use cocogitto_git::Repository;
    use cocogitto_oid::OidOf;
    use cocogitto_test_helpers::open_cocogitto_repo;
    use cocogitto_test_helpers::*;

    use crate::release_from_commits;

    #[test]
    fn should_get_a_release() -> anyhow::Result<()> {
        let repo = open_cocogitto_repo()?;
        let iter = repo.revwalk("..")?;
        let settings = Settings::default();
        let allowed_commits = &settings.allowed_commit_types();
        let omitted_commits = &settings.commit_omitted_from_changelog();
        let changelog_titles = &settings.changelog_titles();
        let usernames = &settings.commit_usernames();

        let release = release_from_commits(
            iter,
            allowed_commits,
            omitted_commits,
            changelog_titles,
            usernames,
        );
        assert_that!(release)
            .is_ok()
            .matches(|r| !r.commits.is_empty());
        Ok(())
    }

    #[sealed_test]
    fn shoud_get_range_for_a_single_release() -> anyhow::Result<()> {
        // Arrange
        let repo = git_init_no_gpg()?;
        let one = commit("chore: first commit")?;
        let two = commit("feat: feature 1")?;
        let three = commit("feat: feature 2")?;
        git_tag("0.1.0")?;

        let range = repo.revwalk("0.1.0");

        let range = range?;

        let settings = Settings::default();
        let allowed_commits = &settings.allowed_commit_types();
        let omitted_commits = &settings.commit_omitted_from_changelog();
        let changelog_titles = &settings.changelog_titles();
        let usernames = &settings.commit_usernames();
        // Act
        let release = release_from_commits(
            range,
            allowed_commits,
            omitted_commits,
            changelog_titles,
            usernames,
        )?;

        // Assert
        assert_that!(release.previous).is_none();
        assert_that!(release.version.oid()).is_equal_to(&Oid::from_str(&three)?);
        assert_that!(release.from).is_equal_to(OidOf::FirstCommit(Oid::from_str(&one)?));

        let expected_commits: Vec<String> = release
            .commits
            .into_iter()
            .map(|commit| commit.commit.oid)
            .collect();

        assert_that!(expected_commits).is_equal_to(vec![three, two, one]);

        Ok(())
    }

    #[sealed_test]
    fn shoud_get_range_for_a_multiple_release() -> anyhow::Result<()> {
        // Arrange
        let repo = git_init_no_gpg()?;
        let one = commit("chore: first commit")?;
        let two = commit("feat: feature 1")?;
        let three = commit("feat: feature 2")?;
        git_tag("0.1.0")?;
        let four = commit("feat: feature 3")?;
        let five = commit("feat: feature 4")?;
        git_tag("0.2.0")?;

        let range = repo.revwalk("..0.2.0")?;
        let settings = Settings::default();
        let allowed_commits = &settings.allowed_commit_types();
        let omitted_commits = &settings.commit_omitted_from_changelog();
        let changelog_titles = &settings.changelog_titles();
        let usernames = &settings.commit_usernames();

        // Act
        let release = release_from_commits(
            range,
            allowed_commits,
            omitted_commits,
            changelog_titles,
            usernames,
        )?;

        // Assert
        assert_that!(release.previous).is_some().matches(|_child| {
            let commits: Vec<String> = release
                .previous
                .as_ref()
                .unwrap()
                .commits
                .iter()
                .map(|commit| commit.commit.oid.clone())
                .collect();

            commits == [three.clone(), two.clone(), one.clone()]
        });

        assert_that!(release.version.to_string()).is_equal_to("0.2.0".to_string());
        assert_that!(release.from.to_string()).is_equal_to("0.1.0".to_string());

        let expected_commits: Vec<String> = release
            .commits
            .into_iter()
            .map(|commit| commit.commit.oid)
            .collect();

        assert_that!(expected_commits).is_equal_to(vec![five, four]);

        Ok(())
    }

    #[test]
    fn get_release_range_integration_test() -> anyhow::Result<()> {
        // Arrange
        let repo = open_cocogitto_repo()?;
        let range = repo.revwalk("0.32.1..0.32.3")?;
        let settings = Settings::default();
        let allowed_commits = &settings.allowed_commit_types();
        let omitted_commits = &settings.commit_omitted_from_changelog();
        let changelog_titles = &settings.changelog_titles();
        let usernames = &settings.commit_usernames();

        // Act
        let release = release_from_commits(
            range,
            allowed_commits,
            omitted_commits,
            changelog_titles,
            usernames,
        )?;

        // Assert
        assert_that!(release.version.to_string()).is_equal_to("0.32.3".to_string());

        let release = *release.previous.unwrap();
        assert_that!(release.version.to_string()).is_equal_to("0.32.2".to_string());

        assert_that!(release.previous).is_none();
        Ok(())
    }

    #[test]
    fn recursive_from_origin_to_head() -> anyhow::Result<()> {
        // Arrange
        let repo = Repository::open(&get_workspace_root())?;
        let mut tag_count = repo.tag_names(None)?.len();
        let head = repo.get_head_commit_oid()?;
        let latest = repo.get_latest_tag(TagLookUpOptions::default())?;
        let latest = latest.oid();
        if latest == Some(&head) {
            tag_count -= 1;
        };

        let range = repo.revwalk("..")?;
        let settings = Settings::default();
        let allowed_commits = &settings.allowed_commit_types();
        let omitted_commits = &settings.commit_omitted_from_changelog();
        let changelog_titles = &settings.changelog_titles();
        let usernames = &settings.commit_usernames();

        // Act
        let mut release = release_from_commits(
            range,
            allowed_commits,
            omitted_commits,
            changelog_titles,
            usernames,
        )?;
        let mut count = 0;

        while let Some(previous) = release.previous {
            release = *previous;
            count += 1;
        }

        // Assert
        assert_that!(count).is_equal_to(tag_count);

        Ok(())
    }

    #[sealed_test]
    fn from_commit_to_head() -> anyhow::Result<()> {
        // Arrange
        let repo = git_init_no_gpg()?;

        commit("chore: init")?;
        commit("feat: a commit")?;
        let one = commit("chore: another commit")?;
        let two = commit("feat: a feature")?;
        let three = commit("chore: 1.0.0")?;
        let four = commit("fix: the bug")?;

        let range = repo.revwalk(&format!("{}..", &one[0..7]))?;
        let settings = Settings::default();
        let allowed_commits = &settings.allowed_commit_types();
        let omitted_commits = &settings.commit_omitted_from_changelog();
        let changelog_titles = &settings.changelog_titles();
        let usernames = &settings.commit_usernames();

        // Act
        let release = release_from_commits(
            range,
            allowed_commits,
            omitted_commits,
            changelog_titles,
            usernames,
        )?;

        // Assert
        let actual_oids: Vec<String> = release
            .commits
            .iter()
            .map(|commit| commit.commit.oid.to_string())
            .collect();

        assert_that!(actual_oids).is_equal_to(vec![four, three, two]);

        Ok(())
    }

    #[sealed_test]
    fn from_commit_to_head_with_overlapping_tag() -> anyhow::Result<()> {
        // Arrange
        let repo = git_init_no_gpg()?;

        commit("chore: init")?;
        commit("feat: a commit")?;

        let from = commit("chore: another commit")?;
        let one = commit("feat: a feature")?;
        let two = commit("chore: 1.0.0")?;
        git_tag("1.0.0")?;
        let three = commit("fix: the bug")?;

        let range = repo.revwalk(&format!("{}..", &from[0..7]))?;
        let settings = Settings::default();
        let allowed_commits = &settings.allowed_commit_types();
        let omitted_commits = &settings.commit_omitted_from_changelog();
        let changelog_titles = &settings.changelog_titles();
        let usernames = &settings.commit_usernames();

        // Act
        let release = release_from_commits(
            range,
            allowed_commits,
            omitted_commits,
            changelog_titles,
            usernames,
        )?;

        // Assert
        let head_to_v1: Vec<String> = release
            .commits
            .iter()
            .map(|commit| commit.commit.oid.to_string())
            .collect();

        let commit_before_v1: Vec<String> = release
            .previous
            .unwrap()
            .commits
            .iter()
            .map(|commit| commit.commit.oid.to_string())
            .collect();

        assert_that!(head_to_v1).is_equal_to(vec![three]);
        assert_that!(commit_before_v1).is_equal_to(vec![two, one]);

        Ok(())
    }
}
